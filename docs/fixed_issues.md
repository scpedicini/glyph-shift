# Installed on Chrome Browser as ZIP Extension in Dev Mode Issues

## Fixed Issues ✅

### 1. Permissions policy violation: unload is not allowed
**Error:** "Permissions policy violation: unload is not allowed in this document."
**Fix:** Replaced deprecated `unload` event listener with `pagehide` event in content.ts:301. Modern browsers block `unload` for security and performance reasons.

### 2. Regenerate button not working in production
**Error:** Button clicks had no effect due to "back/forward cache" closing message channels
**Fix:** Added proper error handling in popup/main.ts:114-148. When message sending fails, the extension now falls back to directly reloading the tab using `browser.tabs.reload()`.

## Original Error Details

These are both coming from the Extension errors area:

Permissions policy violation: unload is not allowed in this document.
Context
https://www.google.com/search?q=simple+wiki+c64&oq=simple+wiki+c64&gs_lcrp=EgZjaHJvbWUyBggAEEUYOTIGCAEQLhhA0gEIMTYwNGowajSoAgCwAgA&sourceid=chrome&ie=UTF-8
Stack Trace
content-scripts/content.js:4 (ft)
content-scripts/content.js:4 (anonymous function)
1
2
3
4
5
6
var content=function(){"use strict";var wt=Object.defineProperty;var bt=(W,V,F)=>V in W?wt(W,V,{enumerable:!0,configurable:!0,writable:!0,value:F}):W[V]=F;var j=(W,V,F)=>bt(W,typeof V!="symbol"?V+"":V,F);var ke,Te,Ne,Pe;function W(t){return t}const F=(Te=(ke=globalThis.browser)==null?void 0:ke.runtime)!=null&&Te.id?globalThis.browser:globalThis.chrome;var ue=Object.prototype.hasOwnProperty;function te(t,e){var r,s;if(t===e)return!0;if(t&&e&&(r=t.constructor)===e.constructor){if(r===Date)return t.getTime()===e.getTime();if(r===RegExp)return t.toString()===e.toString();if(r===Array){if((s=t.length)===e.length)for(;s--&&te(t[s],e[s]););return s===-1}if(!r||typeof t=="object"){s=0;for(r in t)if(ue.call(t,r)&&++s&&!ue.call(e,r)||!(r in e)||!te(t[r],e[r]))return!1;return Object.keys(e).length===s}}return t!==t&&e!==e}const Oe=new Error("request for lock canceled");var Ce=function(t,e,r,s){function d(m){return m instanceof r?m:new r(function(g){g(m)})}return new(r||(r=Promise))(function(m,g){function c(b){try{p(s.next(b))}catch(x){g(x)}}function A(b){try{p(s.throw(b))}catch(x){g(x)}}function p(b){b.done?m(b.value):d(b.value).then(c,A)}p((s=s.apply(t,e||[])).next())})};class Re{constructor(e,r=Oe){this._value=e,this._cancelError=r,this._queue=[],this._weightedWaiters=[]}acquire(e=1,r=0){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);return new Promise((s,d)=>{const m={resolve:s,reject:d,weight:e,priority:r},g=de(this._queue,c=>r<=c.priority);g===-1&&e<=this._value?this._dispatchItem(m):this._queue.splice(g+1,0,m)})}runExclusive(e){return Ce(this,arguments,void 0,function*(r,s=1,d=0){const[m,g]=yield this.acquire(s,d);try{return yield r(m)}finally{g()}})}waitForUnlock(e=1,r=0){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);return this._couldLockImmediately(e,r)?Promise.resolve():new Promise(s=>{this._weightedWaiters[e-1]||(this._weightedWaiters[e-1]=[]),$e(this._weightedWaiters[e-1],{resolve:s,priority:r})})}isLocked(){return this._value<=0}getValue(){return this._value}setValue(e){this._value=e,this._dispatchQueue()}release(e=1){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);this._value+=e,this._dispatchQueue()}cancel(){this._queue.forEach(e=>e.reject(this._cancelError)),this._queue=[]}_dispatchQueue(){for(this._drainUnlockWaiters();this._queue.length>0&&this._queue[0].weight<=this._value;)this._dispatchItem(this._queue.shift()),this._drainUnlockWaiters()}_dispatchItem(e){const r=this._value;this._value-=e.weight,e.resolve([r,this._newReleaser(e.weight)])}_newReleaser(e){let r=!1;return()=>{r||(r=!0,this.release(e))}}_drainUnlockWaiters(){if(this._queue.length===0)for(let e=this._value;e>0;e--){const r=this._weightedWaiters[e-1];r&&(r.forEach(s=>s.resolve()),this._weightedWaiters[e-1]=[])}else{const e=this._queue[0].priority;for(let r=this._value;r>0;r--){const s=this._weightedWaiters[r-1];if(!s)continue;const d=s.findIndex(m=>m.priority<=e);(d===-1?s:s.splice(0,d)).forEach(m=>m.resolve())}}}_couldLockImmediately(e,r){return(this._queue.length===0||this._queue[0].priority<r)&&e<=this._value}}function $e(t,e){const r=de(t,s=>e.priority<=s.priority);t.splice(r+1,0,e)}function de(t,e){for(let r=t.length-1;r>=0;r--)if(e(t[r]))return r;return-1}var Fe=function(t,e,r,s){function d(m){return m instanceof r?m:new r(function(g){g(m)})}return new(r||(r=Promise))(function(m,g){function c(b){try{p(s.next(b))}catch(x){g(x)}}function A(b){try{p(s.throw(b))}catch(x){g(x)}}function p(b){b.done?m(b.value):d(b.value).then(c,A)}p((s=s.apply(t,e||[])).next())})};class De{constructor(e){this._semaphore=new Re(1,e)}acquire(){return Fe(this,arguments,void 0,function*(e=0){const[,r]=yield this._semaphore.acquire(1,e);return r})}runExclusive(e,r=0){return this._semaphore.runExclusive(()=>e(),1,r)}isLocked(){return this._semaphore.isLocked()}waitForUnlock(e=0){return this._semaphore.waitForUnlock(1,e)}release(){this._semaphore.isLocked()&&this._semaphore.release()}cancel(){return this._semaphore.cancel()}}const z=((Pe=(Ne=globalThis.browser)==null?void 0:Ne.runtime)==null?void 0:Pe.id)==null?globalThis.chrome:globalThis.browser,fe=Le();function Le(){const t={local:J("local"),session:J("session"),sync:J("sync"),managed:J("managed")},e=i=>{const a=t[i];if(a==null){const n=Object.keys(t).join(", ");throw Error(`Invalid area "${i}". Options: ${n}`)}return a},r=i=>{const a=i.indexOf(":"),n=i.substring(0,a),o=i.substring(a+1);if(o==null)throw Error(`Storage key should be in the form of "area:key", but received "${i}"`);return{driverArea:n,driverKey:o,driver:e(n)}},s=i=>i+"$",d=(i,a)=>{const n={...i};return Object.entries(a).forEach(([o,h])=>{h==null?delete n[o]:n[o]=h}),n},m=(i,a)=>i??a??null,g=i=>typeof i=="object"&&!Array.isArray(i)?i:{},c=async(i,a,n)=>{const o=await i.getItem(a);return m(o,(n==null?void 0:n.fallback)??(n==null?void 0:n.defaultValue))},A=async(i,a)=>{const n=s(a),o=await i.getItem(n);return g(o)},p=async(i,a,n)=>{await i.setItem(a,n??null)},b=async(i,a,n)=>{const o=s(a),h=g(await i.getItem(o));await i.setItem(o,d(h,n))},x=async(i,a,n)=>{if(await i.removeItem(a),n!=null&&n.removeMeta){const o=s(a);await i.removeItem(o)}},S=async(i,a,n)=>{const o=s(a);if(n==null)await i.removeItem(o);else{const h=g(await i.getItem(o));[n].flat().forEach(w=>delete h[w]),await i.setItem(o,h)}},k=(i,a,n)=>i.watch(a,n);return{getItem:async(i,a)=>{const{driver:n,driverKey:o}=r(i);return await c(n,o,a)},getItems:async i=>{const a=new Map,n=new Map,o=[];i.forEach(w=>{let _,E;typeof w=="string"?_=w:"getValue"in w?(_=w.key,E={fallback:w.fallback}):(_=w.key,E=w.options),o.push(_);const{driverArea:I,driverKey:l}=r(_),u=a.get(I)??[];a.set(I,u.concat(l)),n.set(_,E)});const h=new Map;return await Promise.all(Array.from(a.entries()).map(async([w,_])=>{(await t[w].getItems(_)).forEach(I=>{const l=`${w}:${I.key}`,u=n.get(l),f=m(I.value,(u==null?void 0:u.fallback)??(u==null?void 0:u.defaultValue));h.set(l,f)})})),o.map(w=>({key:w,value:h.get(w)}))},getMeta:async i=>{const{driver:a,driverKey:n}=r(i);return await A(a,n)},getMetas:async i=>{const a=i.map(h=>{const w=typeof h=="string"?h:h.key,{driverArea:_,driverKey:E}=r(w);return{key:w,driverArea:_,driverKey:E,driverMetaKey:s(E)}}),n=a.reduce((h,w)=>{var _;return h[_=w.driverArea]??(h[_]=[]),h[w.driverArea].push(w),h},{}),o={};return await Promise.all(Object.entries(n).map(async([h,w])=>{const _=await z.storage[h].get(w.map(E=>E.driverMetaKey));w.forEach(E=>{o[E.key]=_[E.driverMetaKey]??{}})})),a.map(h=>({key:h.key,meta:o[h.key]}))},setItem:async(i,a)=>{const{driver:n,driverKey:o}=r(i);await p(n,o,a)},setItems:async i=>{const a={};i.forEach(n=>{const{driverArea:o,driverKey:h}=r("key"in n?n.key:n.item.key);a[o]??(a[o]=[]),a[o].push({key:h,value:n.value})}),await Promise.all(Object.entries(a).map(async([n,o])=>{await e(n).setItems(o)}))},setMeta:async(i,a)=>{const{driver:n,driverKey:o}=r(i);await b(n,o,a)},setMetas:async i=>{const a={};i.forEach(n=>{const{driverArea:o,driverKey:h}=r("key"in n?n.key:n.item.key);a[o]??(a[o]=[]),a[o].push({key:h,properties:n.meta})}),await Promise.all(Object.entries(a).map(async([n,o])=>{const h=e(n),w=o.map(({key:l})=>s(l));console.log(n,w);const _=await h.getItems(w),E=Object.fromEntries(_.map(({key:l,value:u})=>[l,g(u)])),I=o.map(({key:l,properties:u})=>{const f=s(l);return{key:f,value:d(E[f]??{},u)}});await h.setItems(I)}))},removeItem:async(i,a)=>{const{driver:n,driverKey:o}=r(i);await x(n,o,a)},removeItems:async i=>{const a={};i.forEach(n=>{let o,h;typeof n=="string"?o=n:"getValue"in n?o=n.key:"item"in n?(o=n.item.key,h=n.options):(o=n.key,h=n.options);const{driverArea:w,driverKey:_}=r(o);a[w]??(a[w]=[]),a[w].push(_),h!=null&&h.removeMeta&&a[w].push(s(_))}),await Promise.all(Object.entries(a).map(async([n,o])=>{await e(n).removeItems(o)}))},clear:async i=>{await e(i).clear()},removeMeta:async(i,a)=>{const{driver:n,driverKey:o}=r(i);await S(n,o,a)},snapshot:async(i,a)=>{var h;const o=await e(i).snapshot();return(h=a==null?void 0:a.excludeKeys)==null||h.forEach(w=>{delete o[w],delete o[s(w)]}),o},restoreSnapshot:async(i,a)=>{await e(i).restoreSnapshot(a)},watch:(i,a)=>{const{driver:n,driverKey:o}=r(i);return k(n,o,a)},unwatch(){Object.values(t).forEach(i=>{i.unwatch()})},defineItem:(i,a)=>{const{driver:n,driverKey:o}=r(i),{version:h=1,migrations:w={}}=a??{};if(h<1)throw Error("Storage item version cannot be less than 1. Initial versions should be set to 1, not 0.");const _=async()=>{var O;const f=s(o),[{value:y},{value:M}]=await n.getItems([o,f]);if(y==null)return;const P=(M==null?void 0:M.v)??1;if(P>h)throw Error(`Version downgrade detected (v${P} -> v${h}) for "${i}"`);if(P===h)return;console.debug(`[@wxt-dev/storage] Running storage migration for ${i}: v${P} -> v${h}`);const R=Array.from({length:h-P},(N,D)=>P+D+1);let v=y;for(const N of R)try{v=await((O=w==null?void 0:w[N])==null?void 0:O.call(w,v))??v}catch(D){throw new je(i,N,{cause:D})}await n.setItems([{key:o,value:v},{key:f,value:{...M,v:h}}]),console.debug(`[@wxt-dev/storage] Storage migration completed for ${i} v${h}`,{migratedValue:v})},E=(a==null?void 0:a.migrations)==null?Promise.resolve():_().catch(f=>{console.error(`[@wxt-dev/storage] Migration failed for ${i}`,f)}),I=new De,l=()=>(a==null?void 0:a.fallback)??(a==null?void 0:a.defaultValue)??null,u=()=>I.runExclusive(async()=>{const f=await n.getItem(o);if(f!=null||(a==null?void 0:a.init)==null)return f;const y=await a.init();return await n.setItem(o,y),y});return E.then(u),{key:i,get defaultValue(){return l()},get fallback(){return l()},getValue:async()=>(await E,a!=null&&a.init?await u():await c(n,o,a)),getMeta:async()=>(await E,await A(n,o)),setValue:async f=>(await E,await p(n,o,f)),setMeta:async f=>(await E,await b(n,o,f)),removeValue:async f=>(await E,await x(n,o,f)),removeMeta:async f=>(await E,await S(n,o,f)),watch:f=>k(n,o,(y,M)=>f(y??l(),M??l())),migrate:_}}}}function J(t){const e=()=>{if(z.runtime==null)throw Error(["'wxt/storage' must be loaded in a web extension environment",`
 - If thrown during a build, see https://github.com/wxt-dev/wxt/issues/371`,` - If thrown during tests, mock 'wxt/browser' correctly. See https://wxt.dev/guide/go-further/testing.html
`].join(`
`));if(z.storage==null)throw Error("You must add the 'storage' permission to your manifest to use 'wxt/storage'");const s=z.storage[t];if(s==null)throw Error(`"browser.storage.${t}" is undefined`);return s},r=new Set;return{getItem:async s=>(await e().get(s))[s],getItems:async s=>{const d=await e().get(s);return s.map(m=>({key:m,value:d[m]??null}))},setItem:async(s,d)=>{d==null?await e().remove(s):await e().set({[s]:d})},setItems:async s=>{const d=s.reduce((m,{key:g,value:c})=>(m[g]=c,m),{});await e().set(d)},removeItem:async s=>{await e().remove(s)},removeItems:async s=>{await e().remove(s)},clear:async()=>{await e().clear()},snapshot:async()=>await e().get(),restoreSnapshot:async s=>{await e().set(s)},watch(s,d){const m=g=>{const c=g[s];c!=null&&(te(c.newValue,c.oldValue)||d(c.newValue??null,c.oldValue??null))};return e().onChanged.addListener(m),r.add(m),()=>{e().onChanged.removeListener(m),r.delete(m)}},unwatch(){r.forEach(s=>{e().onChanged.removeListener(s)}),r.clear()}}}class je extends Error{constructor(e,r,s){super(`v${r} migration failed for "${e}"`,s),this.key=e,this.version=r}}var Ve=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function he(t){return t&&t.__esModule&&Object.prototype.hasOwnProperty.call(t,"default")?t.default:t}var re={exports:{}};const We=t=>typeof crypto<"u"&&typeof crypto.getRandomValues=="function"?()=>{const e=crypto.getRandomValues(new Uint8Array(1))[0];return(e>=t?e%t:e).toString(t)}:()=>Math.floor(Math.random()*t).toString(t),Ae=(t=7,e=!1)=>Array.from({length:t},We(e?16:36)).join("");re.exports=Ae,re.exports.default=Ae;var qe=re.exports;const Y=he(qe);var Ke=()=>`uid::${Y(7)}`,Be=(t,e=["endpointName","fingerprint"])=>typeof t=="object"&&t!==null&&e.every(r=>r in t),Ue=t=>{if(!Be(t))throw new TypeError("Invalid connection args");return JSON.stringify(t)},He=()=>{let t=[];return{add:(...e)=>{t=[...t,...e]},remove:e=>{t=typeof e=="string"?t.filter(r=>r.message.transactionId!==e):t.filter(r=>!e.includes(r))},entries:()=>t}},se=class{static toBackground(t,e){return t.postMessage(e)}static toExtensionContext(t,e){return t.postMessage(e)}},pe={exports:{}};(function(t,e){(function(r,s){s(t)})(typeof globalThis<"u"?globalThis:typeof self<"u"?self:Ve,function(r){if(typeof globalThis!="object"||typeof chrome!="object"||!chrome||!chrome.runtime||!chrome.runtime.id)throw new Error("This script should only be loaded in a browser extension.");if(typeof globalThis.browser>"u"||Object.getPrototypeOf(globalThis.browser)!==Object.prototype){const s="The message port closed before a response was received.",d="Returning a Promise is the preferred way to send a reply from an onMessage/onMessageExternal listener, as the sendResponse will be removed from the specs (See https://developer.mozilla.org/docs/Mozilla/Add-ons/WebExtensions/API/runtime/onMessage)",m=g=>{const c={alarms:{clear:{minArgs:0,maxArgs:1},clearAll:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getAll:{minArgs:0,maxArgs:0}},bookmarks:{create:{minArgs:1,maxArgs:1},get:{minArgs:1,maxArgs:1},getChildren:{minArgs:1,maxArgs:1},getRecent:{minArgs:1,maxArgs:1},getSubTree:{minArgs:1,maxArgs:1},getTree:{minArgs:0,maxArgs:0},move:{minArgs:2,maxArgs:2},remove:{minArgs:1,maxArgs:1},removeTree:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1},update:{minArgs:2,maxArgs:2}},browserAction:{disable:{minArgs:0,maxArgs:1,fallbackToNoCallback:!0},enable:{minArgs:0,maxArgs:1,fallbackToNoCallback:!0},getBadgeBackgroundColor:{minArgs:1,maxArgs:1},getBadgeText:{minArgs:1,maxArgs:1},getPopup:{minArgs:1,maxArgs:1},getTitle:{minArgs:1,maxArgs:1},openPopup:{minArgs:0,maxArgs:0},setBadgeBackgroundColor:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setBadgeText:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setIcon:{minArgs:1,maxArgs:1},setPopup:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setTitle:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},browsingData:{remove:{minArgs:2,maxArgs:2},removeCache:{minArgs:1,maxArgs:1},removeCookies:{minArgs:1,maxArgs:1},removeDownloads:{minArgs:1,maxArgs:1},removeFormData:{minArgs:1,maxArgs:1},removeHistory:{minArgs:1,maxArgs:1},removeLocalStorage:{minArgs:1,maxArgs:1},removePasswords:{minArgs:1,maxArgs:1},removePluginData:{minArgs:1,maxArgs:1},settings:{minArgs:0,maxArgs:0}},commands:{getAll:{minArgs:0,maxArgs:0}},contextMenus:{remove:{minArgs:1,maxArgs:1},removeAll:{minArgs:0,maxArgs:0},update:{minArgs:2,maxArgs:2}},cookies:{get:{minArgs:1,maxArgs:1},getAll:{minArgs:1,maxArgs:1},getAllCookieStores:{minArgs:0,maxArgs:0},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}},devtools:{inspectedWindow:{eval:{minArgs:1,maxArgs:2,singleCallbackArg:!1}},panels:{create:{minArgs:3,maxArgs:3,singleCallbackArg:!0},elements:{createSidebarPane:{minArgs:1,maxArgs:1}}}},downloads:{cancel:{minArgs:1,maxArgs:1},download:{minArgs:1,maxArgs:1},erase:{minArgs:1,maxArgs:1},getFileIcon:{minArgs:1,maxArgs:2},open:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},pause:{minArgs:1,maxArgs:1},removeFile:{minArgs:1,maxArgs:1},resume:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1},show:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},extension:{isAllowedFileSchemeAccess:{minArgs:0,maxArgs:0},isAllowedIncognitoAccess:{minArgs:0,maxArgs:0}},history:{addUrl:{minArgs:1,maxArgs:1},deleteAll:{minArgs:0,maxArgs:0},deleteRange:{minArgs:1,maxArgs:1},deleteUrl:{minArgs:1,maxArgs:1},getVisits:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1}},i18n:{detectLanguage:{minArgs:1,maxArgs:1},getAcceptLanguages:{minArgs:0,maxArgs:0}},identity:{launchWebAuthFlow:{minArgs:1,maxArgs:1}},idle:{queryState:{minArgs:1,maxArgs:1}},management:{get:{minArgs:1,maxArgs:1},getAll:{minArgs:0,maxArgs:0},getSelf:{minArgs:0,maxArgs:0},setEnabled:{minArgs:2,maxArgs:2},uninstallSelf:{minArgs:0,maxArgs:1}},notifications:{clear:{minArgs:1,maxArgs:1},create:{minArgs:1,maxArgs:2},getAll:{minArgs:0,maxArgs:0},getPermissionLevel:{minArgs:0,maxArgs:0},update:{minArgs:2,maxArgs:2}},pageAction:{getPopup:{minArgs:1,maxArgs:1},getTitle:{minArgs:1,maxArgs:1},hide:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setIcon:{minArgs:1,maxArgs:1},setPopup:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setTitle:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},show:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},permissions:{contains:{minArgs:1,maxArgs:1},getAll:{minArgs:0,maxArgs:0},remove:{minArgs:1,maxArgs:1},request:{minArgs:1,maxArgs:1}},runtime:{getBackgroundPage:{minArgs:0,maxArgs:0},getPlatformInfo:{minArgs:0,maxArgs:0},openOptionsPage:{minArgs:0,maxArgs:0},requestUpdateCheck:{minArgs:0,maxArgs:0},sendMessage:{minArgs:1,maxArgs:3},sendNativeMessage:{minArgs:2,maxArgs:2},setUninstallURL:{minArgs:1,maxArgs:1}},sessions:{getDevices:{minArgs:0,maxArgs:1},getRecentlyClosed:{minArgs:0,maxArgs:1},restore:{minArgs:0,maxArgs:1}},storage:{local:{clear:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}},managed:{get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1}},sync:{clear:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}}},tabs:{captureVisibleTab:{minArgs:0,maxArgs:2},create:{minArgs:1,maxArgs:1},detectLanguage:{minArgs:0,maxArgs:1},discard:{minArgs:0,maxArgs:1},duplicate:{minArgs:1,maxArgs:1},executeScript:{minArgs:1,maxArgs:2},get:{minArgs:1,maxArgs:1},getCurrent:{minArgs:0,maxArgs:0},getZoom:{minArgs:0,maxArgs:1},getZoomSettings:{minArgs:0,maxArgs:1},goBack:{minArgs:0,maxArgs:1},goForward:{minArgs:0,maxArgs:1},highlight:{minArgs:1,maxArgs:1},insertCSS:{minArgs:1,maxArgs:2},move:{minArgs:2,maxArgs:2},query:{minArgs:1,maxArgs:1},reload:{minArgs:0,maxArgs:2},remove:{minArgs:1,maxArgs:1},removeCSS:{minArgs:1,maxArgs:2},sendMessage:{minArgs:2,maxArgs:3},setZoom:{minArgs:1,maxArgs:2},setZoomSettings:{minArgs:1,maxArgs:2},update:{minArgs:1,maxArgs:2}},topSites:{get:{minArgs:0,maxArgs:0}},webNavigation:{getAllFrames:{minArgs:1,maxArgs:1},getFrame:{minArgs:1,maxArgs:1}},webRequest:{handlerBehaviorChanged:{minArgs:0,maxArgs:0}},windows:{create:{minArgs:0,maxArgs:1},get:{minArgs:1,maxArgs:2},getAll:{minArgs:0,maxArgs:1},getCurrent:{minArgs:0,maxArgs:1},getLastFocused:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},update:{minArgs:2,maxArgs:2}}};if(Object.keys(c).length===0)throw new Error("api-metadata.json has not been included in browser-polyfill");class A extends WeakMap{constructor(u,f=void 0){super(f),this.createItem=u}get(u){return this.has(u)||this.set(u,this.createItem(u)),super.get(u)}}const p=l=>l&&typeof l=="object"&&typeof l.then=="function",b=(l,u)=>(...f)=>{g.runtime.lastError?l.reject(new Error(g.runtime.lastError.message)):u.singleCallbackArg||f.length<=1&&u.singleCallbackArg!==!1?l.resolve(f[0]):l.resolve(f)},x=l=>l==1?"argument":"arguments",S=(l,u)=>function(y,...M){if(M.length<u.minArgs)throw new Error(`Expected at least ${u.minArgs} ${x(u.minArgs)} for ${l}(), got ${M.length}`);if(M.length>u.maxArgs)throw new Error(`Expected at most ${u.maxArgs} ${x(u.maxArgs)} for ${l}(), got ${M.length}`);return new Promise((P,R)=>{if(u.fallbackToNoCallback)try{y[l](...M,b({resolve:P,reject:R},u))}catch(v){console.warn(`${l} API method doesn't seem to support the callback parameter, falling back to call it without a callback: `,v),y[l](...M),u.fallbackToNoCallback=!1,u.noCallback=!0,P()}else u.noCallback?(y[l](...M),P()):y[l](...M,b({resolve:P,reject:R},u))})},k=(l,u,f)=>new Proxy(u,{apply(y,M,P){return f.call(M,l,...P)}});let T=Function.call.bind(Object.prototype.hasOwnProperty);const i=(l,u={},f={})=>{let y=Object.create(null),M={has(R,v){return v in l||v in y},get(R,v,O){if(v in y)return y[v];if(!(v in l))return;let N=l[v];if(typeof N=="function")if(typeof u[v]=="function")N=k(l,l[v],u[v]);else if(T(f,v)){let D=S(v,f[v]);N=k(l,l[v],D)}else N=N.bind(l);else if(typeof N=="object"&&N!==null&&(T(u,v)||T(f,v)))N=i(N,u[v],f[v]);else if(T(f,"*"))N=i(N,u[v],f["*"]);else return Object.defineProperty(y,v,{configurable:!0,enumerable:!0,get(){return l[v]},set(D){l[v]=D}}),N;return y[v]=N,N},set(R,v,O,N){return v in y?y[v]=O:l[v]=O,!0},defineProperty(R,v,O){return Reflect.defineProperty(y,v,O)},deleteProperty(R,v){return Reflect.deleteProperty(y,v)}},P=Object.create(l);return new Proxy(P,M)},a=l=>({addListener(u,f,...y){u.addListener(l.get(f),...y)},hasListener(u,f){return u.hasListener(l.get(f))},removeListener(u,f){u.removeListener(l.get(f))}}),n=new A(l=>typeof l!="function"?l:function(f){const y=i(f,{},{getContent:{minArgs:0,maxArgs:0}});l(y)});let o=!1;const h=new A(l=>typeof l!="function"?l:function(f,y,M){let P=!1,R,v=new Promise(G=>{R=function(L){o||(console.warn(d,new Error().stack),o=!0),P=!0,G(L)}}),O;try{O=l(f,y,R)}catch(G){O=Promise.reject(G)}const N=O!==!0&&p(O);if(O!==!0&&!N&&!P)return!1;const D=G=>{G.then(L=>{M(L)},L=>{let me;L&&(L instanceof Error||typeof L.message=="string")?me=L.message:me="An unexpected error occurred",M({__mozWebExtensionPolyfillReject__:!0,message:me})}).catch(L=>{console.error("Failed to send onMessage rejected reply",L)})};return D(N?O:v),!0}),w=({reject:l,resolve:u},f)=>{g.runtime.lastError?g.runtime.lastError.message===s?u():l(new Error(g.runtime.lastError.message)):f&&f.__mozWebExtensionPolyfillReject__?l(new Error(f.message)):u(f)},_=(l,u,f,...y)=>{if(y.length<u.minArgs)throw new Error(`Expected at least ${u.minArgs} ${x(u.minArgs)} for ${l}(), got ${y.length}`);if(y.length>u.maxArgs)throw new Error(`Expected at most ${u.maxArgs} ${x(u.maxArgs)} for ${l}(), got ${y.length}`);return new Promise((M,P)=>{const R=w.bind(null,{resolve:M,reject:P});y.push(R),f.sendMessage(...y)})},E={devtools:{network:{onRequestFinished:a(n)}},runtime:{onMessage:a(h),onMessageExternal:a(h),sendMessage:_.bind(null,"sendMessage",{minArgs:1,maxArgs:3})},tabs:{sendMessage:_.bind(null,"sendMessage",{minArgs:2,maxArgs:3})}},I={clear:{minArgs:1,maxArgs:1},get:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}};return c.privacy={network:{"*":I},services:{"*":I},websites:{"*":I}},i(g,E,c)};r.exports=m(chrome)}else r.exports=globalThis.browser})})(pe);var Ge=pe.exports;const ze=he(Ge);var Je=(t="")=>{const e=Ke();let r,s=[];const d=He(),m=new Set,g=new Set,c=(p,b)=>{switch(p.status){case"undeliverable":s.some(x=>x.message.messageID===p.message.messageID)||(s=[...s,{message:p.message,resolvedDestination:p.resolvedDestination}]);return;case"deliverable":s=s.reduce((x,S)=>S.resolvedDestination===p.deliverableTo?(se.toBackground(b,{type:"deliver",message:S.message}),x):[...x,S],[]);return;case"delivered":p.receipt.message.messageType==="message"&&d.add(p.receipt);return;case"incoming":p.message.messageType==="reply"&&d.remove(p.message.messageID),m.forEach(x=>x(p.message,b));return;case"terminated":{const x=d.entries().filter(S=>p.fingerprint===S.to);d.remove(x),x.forEach(({message:S})=>g.forEach(k=>k(S)))}}},A=()=>{r=ze.runtime.connect({name:Ue({endpointName:t,fingerprint:e})}),r.onMessage.addListener(c),r.onDisconnect.addListener(A),se.toBackground(r,{type:"sync",pendingResponses:d.entries(),pendingDeliveries:[...new Set(s.map(({resolvedDestination:p})=>p))]})};return A(),{onFailure(p){g.add(p)},onMessage(p){m.add(p)},postMessage(p){se.toBackground(r,{type:"deliver",message:p})}}},ne,Ye=(t,e,r)=>ne??(ne=new Promise(s=>{const d=g=>{const{data:{cmd:c,scope:A,context:p},ports:b}=g;if(c==="webext-port-offer"&&A===e&&p!==t)return window.removeEventListener("message",d),b[0].onmessage=r,b[0].postMessage("port-accepted"),s(b[0])},m=()=>{const g=new MessageChannel;g.port1.onmessage=c=>{if(c.data==="port-accepted")return window.removeEventListener("message",d),s(g.port1);r==null||r(c)},window.postMessage({cmd:"webext-port-offer",scope:e,context:t},"*",[g.port2])};window.addEventListener("message",d),m()})),Qe=t=>{let e,r=!1,s,d;return{enable:()=>r=!0,onMessage:m=>s=m,postMessage:async m=>{if(!r)throw new Error("Communication with window has not been allowed");return Ze(e),(await d).postMessage(m)},setNamespace:m=>{if(e)throw new Error("Namespace once set cannot be changed");e=m,d=Ye(t,m,({data:g})=>s==null?void 0:s(g))}}};function Ze(t){if(typeof t!="string"||t.trim().length===0)throw new Error(`webext-bridge uses window.postMessage to talk with other "window"(s) for message routingwhich is global/conflicting operation in case there are other scripts using webext-bridge. Call Bridge#setNamespace(nsps) to isolate your app. Example: setNamespace('com.facebook.react-devtools'). Make sure to use same namespace across all your scripts whereever window.postMessage is likely to be used\``)}var Xe=Object.defineProperty,et=Object.defineProperties,tt=Object.getOwnPropertyDescriptors,we=Object.getOwnPropertySymbols,rt=Object.prototype.hasOwnProperty,st=Object.prototype.propertyIsEnumerable,be=(t,e,r)=>e in t?Xe(t,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[e]=r,ve=(t,e)=>{for(var r in e||(e={}))rt.call(e,r)&&be(t,r,e[r]);if(we)for(var r of we(e))st.call(e,r)&&be(t,r,e[r]);return t},ye=(t,e)=>et(t,tt(e)),nt=/^((?:background$)|devtools|popup|options|content-script|window)(?:@(\d+)(?:\.(\d+))?)?$/,xe=t=>{const[,e,r,s]=t.match(nt)||[];return{context:e,tabId:+r,frameId:s?+s:void 0}};const at=[{property:"name",enumerable:!1},{property:"message",enumerable:!1},{property:"stack",enumerable:!1},{property:"code",enumerable:!0}],ae=Symbol(".toJSON was called"),it=t=>{t[ae]=!0;const e=t.toJSON();return delete t[ae],e},Ee=({from:t,seen:e,to_:r,forceEnumerable:s,maxDepth:d,depth:m})=>{const g=r||(Array.isArray(t)?[]:{});if(e.push(t),m>=d)return g;if(typeof t.toJSON=="function"&&t[ae]!==!0)return it(t);for(const[c,A]of Object.entries(t)){if(typeof Buffer=="function"&&Buffer.isBuffer(A)){g[c]="[object Buffer]";continue}if(A!==null&&typeof A=="object"&&typeof A.pipe=="function"){g[c]="[object Stream]";continue}if(typeof A!="function"){if(!A||typeof A!="object"){g[c]=A;continue}if(!e.includes(t[c])){m++,g[c]=Ee({from:t[c],seen:[...e],forceEnumerable:s,maxDepth:d,depth:m});continue}g[c]="[Circular]"}}for(const{property:c,enumerable:A}of at)typeof t[c]=="string"&&Object.defineProperty(g,c,{value:t[c],enumerable:!0,configurable:!0,writable:!0});return g};function ot(t,e={}){const{maxDepth:r=Number.POSITIVE_INFINITY}=e;return typeof t=="object"&&t!==null?Ee({from:t,seen:[],forceEnumerable:!0,maxDepth:r,depth:0}):typeof t=="function"?`[Function: ${t.name||"anonymous"}]`:t}let _e=()=>({events:{},emit(t,...e){(this.events[t]||[]).forEach(r=>r(...e))},on(t,e){return(this.events[t]=this.events[t]||[]).push(e),()=>this.events[t]=(this.events[t]||[]).filter(r=>r!==e)}});var lt=(t,e,r)=>{const s=Y(),d=new Map,m=new Map,g=c=>{if(c.destination.context===t&&!c.destination.frameId&&!c.destination.tabId){const{transactionId:A,messageID:p,messageType:b}=c,x=()=>{const k=d.get(A);if(k){const{err:T,data:i}=c;if(T){const a=T,n=self[a.name],o=new(typeof n=="function"?n:Error)(a.message);for(const h in a)o[h]=a[h];k.reject(o)}else k.resolve(i);d.delete(A)}},S=async()=>{let k,T,i=!1;try{const a=m.get(p);if(typeof a=="function")k=await a({sender:c.origin,id:p,data:c.data,timestamp:c.timestamp});else throw i=!0,new Error(`[webext-bridge] No handler registered in '${t}' to accept messages with id '${p}'`)}catch(a){T=a}finally{if(T&&(c.err=ot(T)),g(ye(ve({},c),{messageType:"reply",data:k,origin:{context:t,tabId:null},destination:c.origin,hops:[]})),T&&!i)throw k}};switch(b){case"reply":return x();case"message":return S()}}return c.hops.push(`${t}::${s}`),e(c)};return{handleMessage:g,endTransaction:c=>{const A=d.get(c);A==null||A.reject("Transaction was ended before it could complete"),d.delete(c)},sendMessage:(c,A,p="background")=>{const b=typeof p=="string"?xe(p):p,x="Bridge#sendMessage ->";if(!b.context)throw new TypeError(`${x} Destination must be any one of known destinations`);return new Promise((S,k)=>{const T={messageID:c,data:A,destination:b,messageType:"message",transactionId:Y(),origin:{context:t,tabId:null},hops:[],timestamp:Date.now()};d.set(T.transactionId,{resolve:S,reject:k});try{g(T)}catch(i){d.delete(T.transactionId),k(i)}})},onMessage:(c,A)=>(m.set(c,A),()=>m.delete(c))}},q=class{constructor(t,e){this.endpointRuntime=t,this.streamInfo=e,this.emitter=_e(),this.isClosed=!1,this.handleStreamClose=()=>{this.isClosed||(this.isClosed=!0,this.emitter.emit("closed",!0),this.emitter.events={})},q.initDone||(t.onMessage("__crx_bridge_stream_transfer__",r=>{const{streamId:s,streamTransfer:d,action:m}=r.data,g=q.openStreams.get(s);g&&!g.isClosed&&(m==="transfer"&&g.emitter.emit("message",d),m==="close"&&(q.openStreams.delete(s),g.handleStreamClose()))}),q.initDone=!0),q.openStreams.set(this.streamInfo.streamId,this)}get info(){return this.streamInfo}send(t){if(this.isClosed)throw new Error("Attempting to send a message over closed stream. Use stream.onClose(<callback>) to keep an eye on stream status");this.endpointRuntime.sendMessage("__crx_bridge_stream_transfer__",{streamId:this.streamInfo.streamId,streamTransfer:t,action:"transfer"},this.streamInfo.endpoint)}close(t){t&&this.send(t),this.handleStreamClose(),this.endpointRuntime.sendMessage("__crx_bridge_stream_transfer__",{streamId:this.streamInfo.streamId,streamTransfer:null,action:"close"},this.streamInfo.endpoint)}onMessage(t){return this.getDisposable("message",t)}onClose(t){return this.getDisposable("closed",t)}getDisposable(t,e){const r=this.emitter.on(t,e);return Object.assign(r,{dispose:r,close:r})}},Q=q;Q.initDone=!1,Q.openStreams=new Map;var ct=t=>{const e=new Map,r=new Map,s=_e();t.onMessage("__crx_bridge_stream_open__",g=>new Promise(c=>{const{sender:A,data:p}=g,{channel:b}=p;let x=!1,S=()=>{};const k=()=>{const T=r.get(b);typeof T=="function"?(T(new Q(t,ye(ve({},p),{endpoint:A}))),x&&S(),c(!0)):x||(x=!0,S=s.on("did-change-stream-callbacks",k))};k()}));async function d(g,c){if(e.has(g))throw new Error("webext-bridge: A Stream is already open at this channel");const A=typeof c=="string"?xe(c):c,p={streamId:Y(),channel:g,endpoint:A},b=new Q(t,p);return b.onClose(()=>e.delete(g)),await t.sendMessage("__crx_bridge_stream_open__",p,A),e.set(g,b),b}function m(g,c){if(r.has(g))throw new Error("webext-bridge: This channel has already been claimed. Stream allows only one-on-one communication");r.set(g,c),s.emit("did-change-stream-callbacks")}return{openStream:d,onOpenStreamChannel:m}},ie=Qe("content-script"),oe=Je(),B=lt("content-script",t=>{t.destination.context==="window"?ie.postMessage(t):oe.postMessage(t)});ie.onMessage(t=>{t.origin={context:"window",tabId:null},B.handleMessage(t)}),oe.onMessage(B.handleMessage),oe.onFailure(t=>{if(t.origin.context==="window"){ie.postMessage({type:"error",transactionID:t.transactionId});return}B.endTransaction(t.transactionId)});var{sendMessage:U,onMessage:vt}=B;ct(B);const Ie={enabled:!0,swapFrequency:5,aslEnabled:!1,morseEnabled:!1,braille1Enabled:!1,braille2Enabled:!1,vorticonEnabled:!1,katakanaEnabled:!1,hiraganaEnabled:!1,romanEnabled:!1,hexEnabled:!1,cockneyEnabled:!1,cockneyFullRhyme:!1};var $=(t=>(t.Hiragana="Hiragana",t.Katakana="Katakana",t.Fingerspelling="Fingerspelling",t.Braille="Braille",t.MorseCode="MorseCode",t.Vorticon="Vorticon",t.Roman="Roman",t.Hex="Hex",t.Cockney="Cockney",t))($||{});function Me(t){return typeof t=="string"&&t.trim().length>0}var Se=(t=>(t[t.NONE=0]="NONE",t[t.ERROR=1]="ERROR",t[t.WARN=2]="WARN",t[t.INFO=3]="INFO",t[t.DEBUG=4]="DEBUG",t))(Se||{});class gt{constructor(e){j(this,"level");j(this,"prefix");j(this,"isDevelopment");this.level=e.level,this.prefix=e.prefix||"[PMapper]",this.isDevelopment=e.isDevelopment??!1}shouldLog(e){return this.isDevelopment&&e<=this.level}formatMessage(e,...r){const s=new Date().toISOString();return[`${this.prefix} [${s}] [${e}]`,...r]}debug(...e){this.shouldLog(4)&&console.log(...this.formatMessage("DEBUG",...e))}info(...e){this.shouldLog(3)&&console.info(...this.formatMessage("INFO",...e))}warn(...e){this.shouldLog(2)&&console.warn(...this.formatMessage("WARN",...e))}error(...e){this.shouldLog(1)&&console.error(...this.formatMessage("ERROR",...e))}setLevel(e){this.level=e}getLevel(){return this.level}}const C=new gt({level:1,prefix:"[PMapper]"}),K={debug:C.debug.bind(C),info:C.info.bind(C),warn:C.warn.bind(C),error:C.error.bind(C),setLevel:C.setLevel.bind(C),getLevel:C.getLevel.bind(C),disable:()=>C.setLevel(0),enable:()=>C.setLevel(1),LogLevel:Se},mt={matches:["<all_urls>"],main(){K.debug("main() content script"),window.addEventListener("pageshow",async()=>{K.debug("Content script loaded");const t=await U("get-random-number",{data:"Hello from content script"});K.debug("Received random number:",t);const e=await fe.getItem("local:phoneticConfig"),r=e?{...Ie,...e}:Ie;r.enabled&&ft(r)}),fe.watch("local:phoneticConfig",(t,e)=>{(t==null?void 0:t.enabled)!==(e==null?void 0:e.enabled)&&window.location.reload()}),F.runtime.onMessage.addListener(t=>{t.type==="regenerateContent"&&(K.debug("Received regeneration request from background script"),window.location.reload())})}};function ut(t){const e=[];return t.aslEnabled&&e.push($.Fingerspelling),(t.braille1Enabled||t.braille2Enabled)&&e.push($.Braille),t.morseEnabled&&e.push($.MorseCode),t.vorticonEnabled&&e.push($.Vorticon),t.katakanaEnabled&&e.push($.Katakana),t.hiraganaEnabled&&e.push($.Hiragana),t.romanEnabled&&e.push($.Roman),t.hexEnabled&&e.push($.Hex),t.cockneyEnabled&&e.push($.Cockney),e}function dt(t){const e=t.match(/^(.+?)([.,!?;:\)\]}'"…]+)$/);return e?{cleanWord:e[1],trailingPunctuation:e[2]}:{cleanWord:t,trailingPunctuation:""}}function ft(t){const e=[],r=new WeakSet;let s=!1;const d=[];async function m(){for(;e.length>0;)try{const A=e[0];await g(A)}finally{e.shift()}setTimeout(m,1e3)}setTimeout(m,500);async function g(A){var x,S;const p=["STYLE","SCRIPT","NOSCRIPT","TEMPLATE"];let b=A.parentElement;for(;b;){if(p.includes(b.tagName))return;b=b.parentElement}if(!(A instanceof Element&&A.hasAttribute("data-pmapper-processed")))if(A.nodeType===Node.TEXT_NODE){if(r.has(A)||(x=A.parentElement)!=null&&x.hasAttribute("data-pmapper-processed"))return;const T=(A.textContent||"").match(/\S+|\s+/g)||[];let i="",a=!1;for(const n of T){if(/^\s+$/.test(n)){i+=n;continue}let o=n;const h=Math.random()*100<t.swapFrequency;if(Me(n)&&h){const{cleanWord:w,trailingPunctuation:_}=dt(n);let E=null;for(let I=0;I<d.length;I++){const l=d[I];if(await U("can-swap",{swapLanguage:l,input:w})){E=l,d.splice(I,1),K.info(`Used neglected module ${l} for word "${n}". Remaining neglected: ${d}`);break}}if(!E){const I=ut(t),l=[],u=[];for(const f of I)await U("can-swap",{swapLanguage:f,input:w})?l.push(f):u.push(f);for(const f of u)d.includes(f)||(await U("get-swap-info",{swapLanguage:f})).isNeglectable&&(d.push(f),K.info(`Added ${f} to neglected modules for word "${n}". Neglected list: ${d}`));l.length>0&&(E=l[Math.floor(Math.random()*l.length)])}if(E){const I=E;let l={};I===$.Braille?l={advancedWords:t.braille2Enabled}:I===$.Cockney&&(l={useFullRhyme:t.cockneyFullRhyme});const u=await U("swap",{swapLanguage:I,input:w,options:l});Me(u)&&(o=u+_)}}a||(a=o!==n),i+=o+" "}if(a){const n=document.createElement("span");n.setAttribute("data-pmapper-processed","true"),n.innerHTML=i,(S=A.parentNode)==null||S.replaceChild(n,A)}r.add(A)}else A.nodeType===Node.ELEMENT_NODE&&e.push(...Array.from(A.childNodes))}const c=new MutationObserver(A=>{if(!s){s=!0;for(const p of A)e.push(...p.addedNodes);s=!1}});return c.observe(document.body,{childList:!0,subtree:!0}),window.addEventListener("unload",()=>{c.disconnect()}),document.body.childNodes.forEach(g),c}function Z(t,...e){}const ht={debug:(...t)=>Z(console.debug,...t),log:(...t)=>Z(console.log,...t),warn:(...t)=>Z(console.warn,...t),error:(...t)=>Z(console.error,...t)},ee=class ee extends Event{constructor(e,r){super(ee.EVENT_NAME,{}),this.newUrl=e,this.oldUrl=r}};j(ee,"EVENT_NAME",ce("wxt:locationchange"));let le=ee;function ce(t){var e;return`${(e=F==null?void 0:F.runtime)==null?void 0:e.id}:content:${t}`}function At(t){let e,r;return{run(){e==null&&(r=new URL(location.href),e=t.setInterval(()=>{let s=new URL(location.href);s.href!==r.href&&(window.dispatchEvent(new le(s,r)),r=s)},1e3))}}}const H=class H{constructor(e,r){j(this,"isTopFrame",window.self===window.top);j(this,"abortController");j(this,"locationWatcher",At(this));j(this,"receivedMessageIds",new Set);this.contentScriptName=e,this.options=r,this.abortController=new AbortController,this.isTopFrame?(this.listenForNewerScripts({ignoreFirstEvent:!0}),this.stopOldScripts()):this.listenForNewerScripts()}get signal(){return this.abortController.signal}abort(e){return this.abortController.abort(e)}get isInvalid(){return F.runtime.id==null&&this.notifyInvalidated(),this.signal.aborted}get isValid(){return!this.isInvalid}onInvalidated(e){return this.signal.addEventListener("abort",e),()=>this.signal.removeEventListener("abort",e)}block(){return new Promise(()=>{})}setInterval(e,r){const s=setInterval(()=>{this.isValid&&e()},r);return this.onInvalidated(()=>clearInterval(s)),s}setTimeout(e,r){const s=setTimeout(()=>{this.isValid&&e()},r);return this.onInvalidated(()=>clearTimeout(s)),s}requestAnimationFrame(e){const r=requestAnimationFrame((...s)=>{this.isValid&&e(...s)});return this.onInvalidated(()=>cancelAnimationFrame(r)),r}requestIdleCallback(e,r){const s=requestIdleCallback((...d)=>{this.signal.aborted||e(...d)},r);return this.onInvalidated(()=>cancelIdleCallback(s)),s}addEventListener(e,r,s,d){var m;r==="wxt:locationchange"&&this.isValid&&this.locationWatcher.run(),(m=e.addEventListener)==null||m.call(e,r.startsWith("wxt:")?ce(r):r,s,{...d,signal:this.signal})}notifyInvalidated(){this.abort("Content script context invalidated"),ht.debug(`Content script "${this.contentScriptName}" context invalidated`)}stopOldScripts(){window.postMessage({type:H.SCRIPT_STARTED_MESSAGE_TYPE,contentScriptName:this.contentScriptName,messageId:Math.random().toString(36).slice(2)},"*")}verifyScriptStartedEvent(e){var m,g,c;const r=((m=e.data)==null?void 0:m.type)===H.SCRIPT_STARTED_MESSAGE_TYPE,s=((g=e.data)==null?void 0:g.contentScriptName)===this.contentScriptName,d=!this.receivedMessageIds.has((c=e.data)==null?void 0:c.messageId);return r&&s&&d}listenForNewerScripts(e){let r=!0;const s=d=>{if(this.verifyScriptStartedEvent(d)){this.receivedMessageIds.add(d.data.messageId);const m=r;if(r=!1,m&&(e!=null&&e.ignoreFirstEvent))return;this.notifyInvalidated()}};addEventListener("message",s),this.onInvalidated(()=>removeEventListener("message",s))}};j(H,"SCRIPT_STARTED_MESSAGE_TYPE",ce("wxt:content-script-started"));let ge=H;function yt(){}function X(t,...e){}const pt={debug:(...t)=>X(console.debug,...t),log:(...t)=>X(console.log,...t),warn:(...t)=>X(console.warn,...t),error:(...t)=>X(console.error,...t)};return(async()=>{try{const{main:t,...e}=mt,r=new ge("content",e);return await t(r)}catch(t){throw pt.error('The content script "content" crashed on startup!',t),t}})()}();
content;
 
Unchecked runtime.lastError: The page keeping the extension port is moved into back/forward cache, so the message channel is closed.